<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CSAPP lab1</title>
    <link href="/2023/10/08/CSAPP-lab1/"/>
    <url>/2023/10/08/CSAPP-lab1/</url>
    
    <content type="html"><![CDATA[<p>该篇博客用于记录从零开始完成CSAPP datalab。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>1.先去B站黑马程序员的Linux网课配置了一下VMware虚拟机及建了一个CentOS7操作系统虚拟机。（后面发现在CentOS7上面有点麻烦，重新建了一个ubuntu操作系统）</p><p>2.<a href="https://blog.csdn.net/kking_Ran/article/details/124782424">ubuntu的配置</a></p><p>3.配置号ubuntu后在虚拟机打开终端执行以下命令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-built_in">get</span> update更新apt软件源<br>sudo apt-<span class="hljs-built_in">get</span> install build-essential安装C/C++编译环境<br>sudo apt-<span class="hljs-built_in">get</span> install gcc-multilib补充gcc完整环境<br>sudo apt-<span class="hljs-built_in">get</span> install gdb安装gdb<br></code></pre></td></tr></table></figure><p>接下来就可以去官网下载datalab-handout开始操作了。每次都是修改bits.c文件里的代码，完成代码后保存，在datalab-handout文件下在终端打开，执行make &amp;&amp; .&#x2F;btest就可以看答案是否正确了。</p><h2 id="1-bitXor"><a href="#1-bitXor" class="headerlink" title="1.bitXor"></a>1.bitXor</h2><p>本题要求是让我们通过~和&amp;实现异或。首先我们要知道什么是异或，异或就是对于两个数x,y，相等时为0，不等时为1，用x^y表示异或运算。</p><p>学过离散数学的都知道，x⊕y &#x3D; (¬x ∧ y) ∨ (x ∧¬y)&#x3D;¬(¬(¬x ∧ y)∧¬(x ∧¬y))</p><p>所以答案就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">return</span> ~(~(~x&amp;y)&amp;~(x&amp;~y));<br></code></pre></td></tr></table></figure><h2 id="2-tmin"><a href="#2-tmin" class="headerlink" title="2.tmin"></a>2.tmin</h2><p>本题要求我们返回二进制形式下，补码表示的最小int值。在本实验int是4个字节，故用32位表示。此时Int的最小取值为-2^31，用补码表示，只需将1左移31为。</p><p>故答案为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>);<br></code></pre></td></tr></table></figure><h2 id="3-isTmax"><a href="#3-isTmax" class="headerlink" title="3.isTmax"></a>3.isTmax</h2><p>本题让我们判断x是不是二进制形式下补码表示的最大数。如果是，返回1。不是，返回0。（建议先理解第五题再来做这道题）</p><p>先理解~x+1与(~x)+1的区别。</p><p>我们对tmax取反后发现，它就是tmin，而tmin有个特征，就是tmin取反就是它本身，通过tmin^(~tmin+1)从而就能判断这个数是不是tmax，但要注意的是，0取反也是它本身，只需再特判一下。</p><p>故本题答案为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">x=~x;<br><span class="hljs-keyword">return</span> !(x^(~x+<span class="hljs-number">1</span>)) &amp; (!!x);<br></code></pre></td></tr></table></figure><p>x如果是0,!!x就为0;x如果为其他任意常数，!!x就为1，从而可以特判x是否为0。</p><h2 id="4-allOldBits"><a href="#4-allOldBits" class="headerlink" title="4.allOldBits"></a>4.allOldBits</h2><p>本题让我们判断给定的二进制数，是不是全部的奇数位都为1（如10101010）。</p><p>我们只需将给定的数&amp;上1010…1010，看最后得到的答案满不满足条件即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> old1=<span class="hljs-number">0xAA</span>;<span class="hljs-comment">//10101010</span><br><span class="hljs-type">int</span> old2=(old1&lt;&lt;<span class="hljs-number">8</span>)+old1;<span class="hljs-comment">//1010101010101010</span><br><span class="hljs-type">int</span> old3=(old2&lt;&lt;<span class="hljs-number">16</span>)+old2;<span class="hljs-comment">//10101010101010101010101010101010</span><br><span class="hljs-keyword">return</span> !((old3&amp;x)^old3);<br></code></pre></td></tr></table></figure><h2 id="5-negate"><a href="#5-negate" class="headerlink" title="5.negate"></a>5.negate</h2><p>本题要求返回一个数的相反数。在二进制补码中，取反加1就是其相反数。</p><p>故答案为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">return</span> (~x)+<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h2 id="6-isAsciiDigit"><a href="#6-isAsciiDigit" class="headerlink" title="6.isAsciiDigit"></a>6.isAsciiDigit</h2><p>本题让我们判断一个数是否位于<code>0x30</code>到<code>0x39</code>之间。在时返回1，不在返回0。</p><p>要做本题，我们需要先了解一下掩码运算（CSAPP原书38页）。大致思路为先判断10位是否为3，再判断个位是否小于等于9。要判断y&gt;&#x3D;x，只需判断y+(-x)&gt;&#x3D;0，故我们要判断a是否小于等于9，只需判断9+（-a）&gt;&#x3D;0，可以通过移位操作得到这个数的符号位，从而来判断一个数是否大于0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> y=x&amp;<span class="hljs-number">0xf</span>;<span class="hljs-comment">//掩码运算得到x的个位</span><br><span class="hljs-keyword">return</span> !((x&gt;&gt;<span class="hljs-number">4</span>)^<span class="hljs-number">0x3</span>) &amp; !((<span class="hljs-number">0x9</span>+(~y+<span class="hljs-number">1</span>))&gt;&gt;<span class="hljs-number">31</span>);<br></code></pre></td></tr></table></figure><h2 id="7-conditional"><a href="#7-conditional" class="headerlink" title="7.conditional"></a>7.conditional</h2><p>本题让我们实现x ? y : z，即x不为0时返回y，为0时返回x。</p><p>x&#x3D;0时我们可以通过（0xfffffff&amp;y)|(0x00000000&amp;z)来得到答案 ，同时x!&#x3D;0时我们可以通过（0x00000000&amp;y)|(0xffffffff&amp;z)来得到答案。故我们只需要判断x是否等于0再来判断是0xfffffff&amp;y还是0x00000000&amp;y。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> checkZero=!!x;<span class="hljs-comment">//x=0,checkZero=0;x!=0,checkZero=1</span><br><span class="hljs-type">int</span> check=~checkZero+<span class="hljs-number">1</span>;<span class="hljs-comment">//checkZero=0,check=0x00000000;checkZero=1,check=0xffffffff</span><br><span class="hljs-keyword">return</span> (check&amp;y)|(~check&amp;z);<br></code></pre></td></tr></table></figure><h2 id="8-isLessOrEqual"><a href="#8-isLessOrEqual" class="headerlink" title="8.isLessOrEqual"></a>8.isLessOrEqual</h2><p>本题让我们判断x&lt;&#x3D;y。只需分别判断同号和异号时的情况。异号时要判断y&gt;&#x3D;x，操作和第六题一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> checkx=x&gt;&gt;<span class="hljs-number">31</span>;<span class="hljs-comment">//判断x的正负</span><br><span class="hljs-type">int</span> checky=y&gt;&gt;<span class="hljs-number">31</span>;<span class="hljs-comment">//判断y的正负</span><br><span class="hljs-type">int</span> checkxy=checkx^checky;<span class="hljs-comment">//判断x,y是否异号</span><br><span class="hljs-type">int</span> xx=~x+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> (checkx&amp;checky&amp;!checkxy)|(!checkxy&amp;!((y+xx)&gt;&gt;<span class="hljs-number">31</span>));<br></code></pre></td></tr></table></figure><h2 id="9-logicalNeg"><a href="#9-logicalNeg" class="headerlink" title="9.logicalNeg"></a>9.logicalNeg</h2><p>本题让我们实现！运算，也就是x&#x3D;0时返回1，否则返回0。我们只需要知道只有0与其相反数或后，所有位才为0。正数负数的相反数必为负数或正数，符号位必不同，或之后符号位必为1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">return</span> ((x|(~x+<span class="hljs-number">1</span>))&gt;&gt;<span class="hljs-number">31</span>)+<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h2 id="10-howManyBits"><a href="#10-howManyBits" class="headerlink" title="10.howManyBits"></a>10.howManyBits</h2><p>本题要求我们返回一个数在二进制补码的表达形式下，最少需要多少位才能表达出来。</p><p>要做本题，我们要清楚以下结论：</p><p>当x为正数时，假设y表示1的最高位置，该数需要y+1位表达出来；如果x为负数时，将x取反，假设y表示1的最高位置，该数需要y+1位表达出来。</p><p>所有我们可以通过找最高的1的位置来确定答案。不能使用循环，所以我们采取二分的方式来操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> b16,b8,b4,b2,b1,b0;<br>  <span class="hljs-type">int</span> signX = x&gt;&gt;<span class="hljs-number">31</span>;<br>  x = ((~signX) &amp; x) | (signX&amp;(~x));<br>  b16 = (!!(x&gt;&gt;<span class="hljs-number">16</span>))&lt;&lt;<span class="hljs-number">4</span>; <br>  x=x&gt;&gt;b16;<br>  b8 = (!!(x&gt;&gt;<span class="hljs-number">8</span>))&lt;&lt;<span class="hljs-number">3</span>;<br>  x=x&gt;&gt;b8;<br>  b4 = (!!(x&gt;&gt;<span class="hljs-number">4</span>))&lt;&lt;<span class="hljs-number">2</span>;<br>  x=x&gt;&gt;b4;  <br>  b2 = (!!(x&gt;&gt;<span class="hljs-number">2</span>))&lt;&lt;<span class="hljs-number">1</span>;<br>  x=x&gt;&gt;b2; <br>  b1 = !!(x&gt;&gt;<span class="hljs-number">1</span>);<br>  x = x&gt;&gt;b1;<br>  b0 = x;<br>  <span class="hljs-keyword">return</span> b0+b1+b2+b4+b8+b16+<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android网络技术的使用</title>
    <link href="/2023/09/12/Android%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/09/12/Android%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="使用HTTP协议访问网络"><a href="#使用HTTP协议访问网络" class="headerlink" title="使用HTTP协议访问网络"></a>使用HTTP协议访问网络</h2><p>HTTP的工作原理：客户端向网络端发送一条HTTP协议请求，服务器收到请求后返回一些数据给客户端，然后客户端对这些数据进行解析和处理就可以了。</p><h3 id="使用HttpURLConnection"><a href="#使用HttpURLConnection" class="headerlink" title="使用HttpURLConnection"></a>使用HttpURLConnection</h3><p>使用步骤：</p><p>1.先获取HttpURLConnection，要获取这个实例，一般只需new出一个URL对象，并传入目标网络地址，然后调用openConnection()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">URL url=<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>);<br>HttpURLConnection connection=(HttpURLConnection) url.openConnection();<br></code></pre></td></tr></table></figure><p>2.设置HTTP的请求方式：GET（从服务器获取数据）、POST（提交数据给服务器）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取数据</span><br>connection.setRequestMethod(<span class="hljs-string">&quot;GET&quot;</span>);<br></code></pre></td></tr></table></figure><p>若要进行提交数据到数据库操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将用户名和密码提交数据库</span><br>connection.setRequestMethod(<span class="hljs-string">&quot;POST&quot;</span>);<br>DataOutputStream out=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(connection.getOutputStream());<br>out.writeBytes(<span class="hljs-string">&quot;username=admin&amp;&amp;password=123456&quot;</span>);<br></code></pre></td></tr></table></figure><p>3.调用getInputStream()方法获取服务器返回的数据流，接下来对输入流进行读取(第一行代码317页)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">InputStream in=connection.getInputStream();<br></code></pre></td></tr></table></figure><p>4.最后调用disconnection()将HTTP连接关闭</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">connection.disconnect();<br></code></pre></td></tr></table></figure><p>注意：在AndroidManifest.xml声明网络权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.INTERNET&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h3 id="使用OkHttp"><a href="#使用OkHttp" class="headerlink" title="使用OkHttp"></a>使用OkHttp</h3><p>在build.gradle文件中添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">implementation &#x27;com.squareup.okhttp3:okhttp:4.9.0&#x27;<br></code></pre></td></tr></table></figure><p>使用步骤：</p><p>1.创建一个OkHttpClient实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">OkHttpClient client=<span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpClient</span>();<br></code></pre></td></tr></table></figure><p>2.创建Request对象用来发起HTTP请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Request request=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>.Builder()<br>    .url(<span class="hljs-string">&quot;目标网络地址&quot;</span>)<br>    .build();<br></code></pre></td></tr></table></figure><p>3.调用OkHttpClient的newCall()方法创建Call对象，并调用它的excute()方法发送请求并获取返回的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Response response=client.newCall(request).execute();<br></code></pre></td></tr></table></figure><p>4.上述的response就是数据库返回的数据了,接下来得到具体内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String responseData=response.body().string();<br></code></pre></td></tr></table></figure><p>若要发送一条POST请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">RequestBody requestBody=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FormBody</span>.Builder()<br>    .add(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;admin&quot;</span>)<br>    .add(<span class="hljs-string">&quot;password&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>)<br>    .build();<br>Request request=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>.Builder()<br>    .url(<span class="hljs-string">&quot;目标网站&quot;</span>)<br>    .post(requestBody)<br>    .build();<br></code></pre></td></tr></table></figure><h2 id="解析JSON格式数据"><a href="#解析JSON格式数据" class="headerlink" title="解析JSON格式数据"></a>解析JSON格式数据</h2><p>在Apache&#x2F;htdocs目录中新建一个.json文件，在文件中以JSON格式编写内容</p><h3 id="使用JSONObject"><a href="#使用JSONObject" class="headerlink" title="使用JSONObject"></a>使用JSONObject</h3><p>将得到的responseData传入JSONArray对象中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">JSONArray jsonArray=<span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONArray</span>(responseData);<br></code></pre></td></tr></table></figure><p>遍历这个JSONArray对象，每次得到一个JSONObject对象，调用getSting()方法将数据取出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;jsonArray.length();i++)&#123;<br>    JSONObject jsonObject=jsonArray.getJSONObject(i);<br>    <span class="hljs-comment">//获得服务器端id的数据</span><br>    string id=jsonObject.getString(<span class="hljs-string">&quot;id&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用GSON"><a href="#使用GSON" class="headerlink" title="使用GSON"></a>使用GSON</h3><p>在build.gradle文件中添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">implementation &#x27;com.google.code.gson:gson:2.9.0&#x27;<br></code></pre></td></tr></table></figure><p>GSON可以将JSON格式的字符串自动映射成一个对象</p><p>例如我们有如下一个json文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>  <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;5&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;5.5&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Clash of Clans&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;6&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;7.0&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Boom Beach&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;7&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3.5&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Clash Royale&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>我们可以先新建一个App类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">private</span> String id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String version;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(String id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getVersion</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> version;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVersion</span><span class="hljs-params">(String version)</span> &#123;<br>        <span class="hljs-built_in">this</span>.version = version;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现要解析这个JSON数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Gson gson=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();<br>List&lt;App&gt; appList=gson.fromJson(responseData,<span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeToken</span>&lt;List&lt;App&gt;&gt;()&#123;&#125;.getType());<br><span class="hljs-keyword">for</span>(App app:appList)&#123;<br>    <span class="hljs-comment">//调用getId()、getName()、getVersion()方法</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Retrofit网络库"><a href="#Retrofit网络库" class="headerlink" title="Retrofit网络库"></a>Retrofit网络库</h2><p>Retrofit与OkHttp不同的是，OkHttp侧重的是底层通信的实现，而Retrofit侧重的是上层接口的封装。Retrofit是在OkHttp的基础上进一步开发出来的应用层网络通信库，让我们可以用面向对象的思想进行网络操作。</p><p>###Retrofit的设计思想：</p><p>1.我们可以先配置好一个根路径，在指定服务器接口时只需要使用相对路径，这样我们就不用每次都指定完整的URL地址了。</p><p>2.Retrofit允许我们对服务器的接口进行归类，让属于同一类功能在一个接口内，这样可以使我们的代码结构更加合理。</p><p>3.我们不用关心网络通信的细节，只需要在接口文件内声明一系列方法和返回值，通过注解指定该方法对应哪个服务器接口，以及要提供的参数。在程序中调用该方法时，Retrofit会自动向对应的服务器接口发起请求，并将响应的数据类型解析成返回值声明的类型。<br>###Retrofit的使用：</p><p>在build.gradle文件中添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">implementation &#x27;com.squareup.retrofit2:retrofit:2.6.1&#x27;<br>implementation &#x27;com.squareup.retrofit2:converter-gson:2.6.1&#x27;<br></code></pre></td></tr></table></figure><p>Retrofit是基于OkHttp开发的，第一天依赖会把OkHttp库下载，无需手动引入。第二条依赖会把GSON库下载。</p><p>例如此时我们有一个同上使用GSON解析数据方法的json文件，由于Retrofit会借助GSON将JSON文件映射成对象，所以在这我们同样需要有一个App类：</p><p>Java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">private</span> String id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String version;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(String id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getVersion</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> version;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVersion</span><span class="hljs-params">(String version)</span> &#123;<br>        <span class="hljs-built_in">this</span>.version = version;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Kotlin代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kot">class App(val id:String,val name:String,val version:String) &#123;&#125;<br></code></pre></td></tr></table></figure><p>接下来我们就可以根据服务器接口的功能创建不同种类的接口文件了（对应上述Retrofit的设计思想中的2）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">AppService</span> &#123;<br>    <span class="hljs-comment">//使用注解来指定功能，@GET表示从服务器取数据</span><br>    <span class="hljs-meta">@GET(<span class="hljs-string">&quot;get_data.json&quot;</span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getAppData</span><span class="hljs-params">()</span></span>: Call&lt;List&lt;App&gt;&gt;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到在这个接口文件内我们创建了一个getAppData()方法，这个方法上面有个@GET注解，表示我们想从服务器上获取数据，注解后面跟的是我们请求地址的相对路径。Call&lt;&gt;通过泛型来指定我们从服务器上获取的数据要转换成什么类型，这里我们想转换成数组，故为Call&lt;List<App>&gt;</p><p>接下来就是在活动中获取Retrofit对象了，baseUrl()表设置根路径，这样就不用每次指定完整的URL了（对应上述Retrofit的设计思想中的1），addConverterFactory()指定Retrofit在解析数据时使用的解析库</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> retrofit=Retrofit.Builder()<br>    .baseUrl(<span class="hljs-string">&quot;http://192.168.31.110:8080/&quot;</span>)<br>    .addConverterFactory(GsonConverterFactory.create())<br>    .build()<br></code></pre></td></tr></table></figure><p>接下来用create()方法来创建一个动态代理对象，传入我们上面创好的接口，这样我们就可以用接口中的方法了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> appService=retrofit.create(AppService::<span class="hljs-keyword">class</span>.java)<br></code></pre></td></tr></table></figure><p>接下来调用接口中的getAppData()方法时，会返回一个Call&lt;List<App>&gt;对象，再调用enqueue()方法，Retrofit就会根据注解后面配置的相对路径进行网络请求了，服务器响应的数据会回调到Callback里，在Callback的onResponse()方法中，调用response.body()方法解析服务器传回的数据，最后遍历list。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">appService.getAppData().enqueue(<span class="hljs-keyword">object</span>: Callback&lt;List&lt;App&gt;&gt;&#123;<br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">List</span>&lt;<span class="hljs-type">App</span>&gt;&gt;, response: <span class="hljs-type">Response</span>&lt;<span class="hljs-type">List</span>&lt;<span class="hljs-type">App</span>&gt;&gt;)</span></span> &#123;<br>                    <span class="hljs-comment">//解析数据</span><br>                    <span class="hljs-keyword">val</span> list=response.body()<br>                    <span class="hljs-keyword">if</span>(list!=<span class="hljs-literal">null</span>)&#123;<br>                        <span class="hljs-keyword">for</span>(app <span class="hljs-keyword">in</span> list)&#123;<br>                           <br>                        &#125;<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">List</span>&lt;<span class="hljs-type">App</span>&gt;&gt;, t: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>                    t.printStackTrace()<br>                &#125;<br>            &#125;)<br></code></pre></td></tr></table></figure><h3 id="Retrofit构建器的最佳写法"><a href="#Retrofit构建器的最佳写法" class="headerlink" title="Retrofit构建器的最佳写法"></a>Retrofit构建器的最佳写法</h3><p>因为Retrofit对象是全局通用的，只需要在调用create()方法时针对不同的接口传进不同的class类型。所有我们可以将构建Retrofit对象封装起来，简化每次获取动态代理对象的过程。</p><p>创建一个ServiceCreator单例类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> ServiceCreator &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> BASE_URL=<span class="hljs-string">&quot;http://192.168.31.110:8080/&quot;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> retrofit=Retrofit.Builder()<br>        .baseUrl(BASE_URL)<br>        .addConverterFactory(GsonConverterFactory.create())<br>        .build()<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span><span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">create</span><span class="hljs-params">(serviceClass: <span class="hljs-type">Class</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>:T= retrofit.create(serviceClass)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，当我们每次想创建某接口的动态代理对象时，不需要构建Retrofit对象，只需以下写法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> appService=ServiceCreator.create(AppService::<span class="hljs-keyword">class</span>.java)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
